\documentclass{article}
% basics
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref} 
\usepackage[labelfont=bf]{caption}
\usepackage{algpseudocode}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]

% unique math expressions:  
\usepackage{amsmath}
\DeclareMathOperator*{\andloop}{\wedge}
\DeclareMathOperator*{\pr}{Pr}
\DeclareMathOperator*{\approach}{\longrightarrow}
\DeclareMathOperator*{\eq}{=}

% grey paper
\usepackage{xcolor}
% \pagecolor[rgb]{0.11,0.11,0.11}
% \color{white}

% embedded code sections
\usepackage{listings}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\usepackage{tikz}
\usetikzlibrary{calc,arrows,positioning}

\newcommand{\lv}[0]{\overline{v}}
\newcommand{\lx}[0]{\overline{x}}

\lstset{style=mystyle}

\begin{document}
\tikzset{
    treenode/.style = {align=center},
    c/.style = {treenode,circle,draw=black,minimum width=1.5em,minimum height=1.5em,text centered,font=\footnotesize},
    r/.style = {treenode,rectangle,draw=black,minimum width=1.5em,minimum height=1.5em,text centered,font=\footnotesize},
    level 1/.style={sibling distance=60mm},
    level 2/.style={sibling distance=30mm},
    level 3/.style={sibling distance=15mm},
    level 4/.style={sibling distance=7mm}
}
\author{Yosef Goren}
\title{Software Verification Homework 4}
\maketitle

\section{BDD constructions}
%enumerate with letters:
\begin{enumerate}[label=\textbf{\alph*.}]
    \item 
        Denote the set of vertices: $V=\{\lx_i\mid i\in[n]\}$\\
        Let $E(\lv):=E_0(\lv)\wedge E_1(\lv)$.
        \[
            A'(\lv):=A(\lv)\wedge \left(\bigwedge_{i=0}^n(E(\lv,\lx_i)\Rightarrow B(\lx_i))\right)
        \]
        The idea is that $A(\lv)$ means the 'accepted' node has to be from $A$,
        and rest of the expression means that all of it's neighbors have to be in $B$.
        It is equivalent to satisfying the following formula:
        \[
            (\lv\in V)\wedge \left(\forall \lx\in V, E(\lx, \lv)\rightarrow B(\lx)\right)
        \]
    \item 
        \[
            V_{1,2}(\lv,\lv'):=
                \left(\bigvee_{i=0}^nE_1(\lv, \lx_i)\wedge E_0(\lx_i, \lv')\right)
                \vee
                \left(\bigvee_{i=0}^nE_0(\lv, \lx_i)\wedge E_1(\lx_i, \lv')\right)
        \]
        For the vertices $\lv,\lv'$ to have a 
        path of length 2 and weight 1 between them,
        there must either be a path of length 2 with weight
        1 were the edge connected to $\lv$ is 1 and the other edge is 0,
        or the other way around.\\
        The primary operator of the expression above describes this fact;
        to be more specific - the left side of the expression
        describes the case where there is a path of length 2 
        were the node connected to $\lv$ has weight 1, and so on.
    \item The algorithm works as follows:
    \begin{algorithmic}
        \State $l\leftarrow 0$
        \State $T(v)\leftarrow\emptyset$
        \State $T'(v)\leftarrow A(v)$
        \While{$T'(V)\neq T(v)$}
            \While{$T'(V)\neq T(v)$}
                \State $T(v)\leftarrow T'(v)$
                \State $T'(v)\leftarrow T'(v)\wedge\left(\bigvee_{i=0}^nE_0(v,v_i)\right)$
                \If{$B(v)\wedge T'(v)\neq\emptyset$}
                    \State \Return $l$
                \EndIf
            \EndWhile
            \State $T(v)\leftarrow T'(v)$
            \State $T'(v)\leftarrow T'(v)\wedge\left(\bigvee_{i=0}^nE_1(v,v_i)\right)$
            \State $l\leftarrow l+1$
            \If{$B(v)\wedge T'(v)\neq\emptyset$}
                \State \Return $l$
            \EndIf
        \EndWhile
        \State \Return $-1$
    \end{algorithmic}
\end{enumerate}
    
\section{BDD operations}
\begin{enumerate}[label=\textbf{\alph*.}]
\item
    \begin{enumerate}[label=\textbf{\arabic*.}]
    \item True. $D\subseteq D'$.\\
        Proof:\\
        Let $x\in D$. Denote the path of $x$ on $B$ with $a_1,a_2,...,a_n$.\\
        Since $x\in D$ then $B(x)=1$, meaning the path must end with $1$.
        If $\exists i\in[n]: a_i=u$.
        then on the evaluation of $x$ on $B'$,
        the path will be $a_1,a_2,...,a_{i-1},u,1$.
        Thus $B'(x)=1$ and so $x\in D'$ in this case.\\
        Otherwise, $x\notin D$. Thus the path $a_1,...,a_n$ is
        unchanged in $B'$ w.r. to $B$. Hence $B'(x)$ evaluates
        on the exact same path - which we know ends with $1$.
        Hence $B'(x)=1$ too, so $x\in D'$.\\
        Meaning in all cases $x\in D'$.\\
        So $D\subseteq D'$.
    \item False. %$D'\subsetneq D$.\\
        Counter example:\\
        Consider kripke structure $(S=\{0,1\},R=\{(s,s)\mid s\in S\},L=\{(s,\emptyset)\mid s\in S\})$.
        Consider $D=\{1\}$.\\
        Let $B$ be the BDD representing $D$:\\
        \begin{center}\begin{tikzpicture}[->,>=stealth',thick]
        \node[c]{$a_0$}
            child{ node[r] {0}}
            child{ node[r] {1}}
        ;\end{tikzpicture}\end{center}
        Now consider $u$ as $a_0$. This would mean $B'$ is: aa asdas
        \begin{center}\begin{tikzpicture}[->,>=stealth',thick]
        \node[c]{$a_0$}
            child{ node[r] {1}}
        ;\end{tikzpicture}\end{center}
        (Technically the $a_0$ would be reduced...).\\
        So now $B'(0)=1$ also, hence $D'=\{0,1\}\not\subseteq D$.
    \end{enumerate}
    \item
    a
\end{enumerate}





% \begin{tikzpicture}[->,>=stealth',thick] 
% \node[c] {a}
% node[c] {c}
%     child{ node[c] {d}
%         child{ node[r] {0}}
%         child{ node[r] {0}}
%     }
%     child{ node[c] {d}
%         child{ node[r] {0}}
%         child{ node[r] {1}}
%     }
% ;
% \end{tikzpicture}

\section{D\&D}
Solution for \textbf{a.+b.}\\
For the purpose of part \textbf{b.} we have assumed 
that the knight can only carry one princess at a time
and each dragon takes the princess away if reached.\\

In the solution we use the following notations:
\begin{itemize}
    \item $\{v_i\mid i\in[n]\}$: the set of vertices ('squares').
    \item $V(v)$: a BDD representing the set of vertices.
    \item $E(v,v')$: a BDD representing the \textbf{REVERSE} set of edges (a transition from $v$ into $v'$).
    \item $S$: a BDD representing the set of starting vertecies.
    \item $F$: a BDD representing the set of final vertecies.
    \item $D$: a BDD representing the set of vertices with a dragon on them.
    \item $P$: a BDD representing the set of vertices with a princess on them.
    \item $N:=V\wedge\neg(S\vee F\vee D\vee P)$ (the set of 'normal' vertices).
    \item $\Phi_U(v):=\bigvee_{i=1}^n(U(v)\wedge E(v,v_i))$.\\
        $\Phi_U$ is simply a 'macro' for ease of readability.\\
        Given a set $U$, $\Phi_U$ is the set of vertecies that are directly connected to a vertex in $U$.\\
        The evaluation $\Phi_U(v)$ is $1$ iff there is a vertex in $U$ that is connected to $v$.
\end{itemize}

We present a single algorithm that can handle multiple dragons.\\
The structure of the algorithm is that we hold
multiple sets that are represented as BDDs, and we manipulate
these sets in each iteration s.t. when the algorithm ends,
one of them will contain the set of all valid paths.\\

In our algorithm we look for reverse paths, meaning paths from
a final state to a starting state - on a graph with reversed edges.\\

The main idea of the algorithm is that we will start with the
set of finishing squares,
and in each iteration 'expand' to all neighboring squares,
but if we encounter a dragon we will have to move
each node that was reached through a dragon into a new
set of 'debt' paths (more accurately - squares that were reached from an final square thorugh
a dragon square). Now if we step from a square with debt into
a starting square, we know the path is not valid, but if
we step from a square with no debt into a starting square,
then we know we have a path that started from a final square
and ended in a starting square were each dragon we have passed through
has be 'paid' for with a princess.\\
If we encounter a princess from the debt set - we can
move into the non-debt set,
if we encounter a princess from the non-debt set - 
we have 'no use' for her since all dragons
in the rest of the path have already been paid for (we have no debt!),
hence we stay in the non-debt set.\\

These transitions between the sets are described with the following atomata:\\

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
    \draw [black] (19.5,-9.1) circle (3);
    \draw (19.5,-9.1) node {$Cur$};
    \draw [black] (3.2,-9.1) circle (3);
    \draw (3.2,-9.1) node {$Debt$};
    \draw [black] (37,-9.1) circle (3);
    \draw (37,-9.1) node {$Valid$};
    \draw [black] (22.5,-9.1) -- (34,-9.1);
    \fill [black] (34,-9.1) -- (33.2,-8.6) -- (33.2,-9.6);
    \draw (28.25,-9.6) node [below] {$S$};
    \draw [black] (5.964,-7.944) arc (107.81821:72.18179:17.601);
    \fill [black] (5.96,-7.94) -- (6.88,-8.17) -- (6.57,-7.22);
    \draw (11.35,-6.6) node [above] {$D$};
    \draw [black] (1.877,-6.42) arc (234:-54:2.25);
    \draw (3.2,-1.85) node [above] {$F,N$};
    \fill [black] (4.52,-6.42) -- (5.4,-6.07) -- (4.59,-5.48);
    \draw [black] (18.177,-6.42) arc (234:-54:2.25);
    \draw (19.5,-1.85) node [above] {$P,N,F,S$};
    \fill [black] (20.82,-6.42) -- (21.7,-6.07) -- (20.89,-5.48);
    \draw [black] (16.836,-10.468) arc (-68.55273:-111.44727:15.003);
    \fill [black] (16.84,-10.47) -- (15.91,-10.3) -- (16.27,-11.23);
    \draw (11.35,-12.01) node [below] {$P$};
\end{tikzpicture}
\end{center}


The algorithm :
\begin{algorithmic}
    \State $Cur\leftarrow F, Debt\leftarrow\emptyset, Valid\leftarrow\emptyset$
    \For{$\_\in[n]$}
        \State Do the following 3 assigments atomically (*):
        \State $
            Cur\leftarrow
                \left(\Phi_{Cur}\wedge(P\vee N\vee F\vee S)\right)
                \vee
                \left(\Phi_{Debt}\wedge P\right)
        $
        \State $
            Debt\leftarrow
                \left(\Phi_{Cur}\wedge D\right)
                \vee
                \left(\Phi_{Debt}\wedge (F\vee N)\right)
        $
        \State $
            Valid\leftarrow
                \left(\Phi_{Cur}\wedge S\right)
        $
    \EndFor
    \State \Return $Valid$
\end{algorithmic}
(*) making a set of assignments atomically
means that all rvalues are evaluated before any
lvalues are assigned.\\


\end{document}